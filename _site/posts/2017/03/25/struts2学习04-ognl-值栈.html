<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<meta http-equiv="content-language" content="zh-CN" />
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
		<meta name="keywords" content="TMaize,java"/>
		<meta name="author" content="TMaize" />
		<meta name="description" content="Struts2学习-04 OGNL 值栈"/>
		<link rel="icon" href="/static/img/favicon.ico" type="image/x-icon" />
		<link rel="shortcut icon" href="/static/img/favicon.ico" type="image/x-icon"/>
		<link rel="stylesheet" href="/static/css/blog.css">
		<link rel="stylesheet" href="/static/css/blog-post.css">
		<script>window.blog={contextPath:""}</script>
		<script type="text/javascript" src="/static/js/blog.js"></script>
		<title>Struts2学习-04 OGNL 值栈-TMaize Blog</title>
	</head>
<body>
<header class="header select-none">
    <a class="logo" title="TMaize Blog" href="/">
        <img src="/static/img/logo.jpg">
    </a>
    <a class="title" href="/">TMaize Blog</a>
    <nav class="menu">
        <a href="/">Blog</a>
        <a href="/pages/categories.html">Categories</a>
        <a href="/pages/search.html">Search</a>
        <a href="/pages/links.html">Links</a>
        <a href="/pages/chat.html">Chat</a>
        <a href="/pages/about.html">About</a>
    </nav>
    <span class="icon"></span>
</header>
	<div class="main animation-fadeUp post">
		
		<h1 class="title">Struts2学习-04 OGNL 值栈</h1>
		
		<div class="content"><h2 id="struts2">struts2标签</h2>

<p>使用需要在jsp中引入标签库<code class="highlighter-rouge">&lt;%@ taglib uri="/struts-tags" prefix="s"%&gt;</code></p>

<h2 id="ognl">OGNL概述</h2>

<ul>
  <li>
    <p>类似于在jsp中的el表达式，el表达式在jsp中获取域对象里面的值。同样OGNL也是一种表达式，不过这个功能更加强大</p>
  </li>
  <li>
    <p>OGNL不是Struts的一部分，它是一个单独的项目，经常和Struts的标签搭配使用操作值栈。所以使用时先要导入jar包</p>
  </li>
  <li>
    <p>使用方法<code class="highlighter-rouge">&lt;s:property value="ognl表达式"/&gt;</code>,比如结合struts2标签计算字符串长度<code class="highlighter-rouge">&lt;s:property value="'haha'.length()"/&gt;</code></p>
  </li>
  <li>
    <p>Struts2默认的表达式语言就是OGNL</p>

    <p>支持对象方法的调用,格式objName.f()</p>

    <p>支持静态方法和值的访问，格式<code class="highlighter-rouge">@[类全名(包括包路径)]@[方法名|值名]</code>，例如：<code class="highlighter-rouge">@java.lang.String@format('foo %s','bar')</code></p>

    <p>支持赋值操作和表达式串联</p>

    <p>访问OGNL上下文(OGNL Context)  Action Context</p>

    <p>操作集合对象</p>
  </li>
</ul>

<h3 id="section">#和%的使用</h3>

<p>使用#来获取context里面的数据</p>

<p>```
HttpServletRequest request = ServletActionContext.getRequest();
request.setAttribute(“name”, “haha”);</p>

<p>//页面中</p>
<s:property value="#request.name" />

<p>```</p>

<p>%的使用主要用于struts2标签中的表单标签，如果直接在struts2表单标签里面使用ognl表达式
不识别，只有使用%号后才会识别</p>

<p>```jsp
<input type="text" value="${name}" /></p>

<!-- 在struts2的标签中获得request域的值 -->
<!-- 无法识别 -->
<s:textfield name="name" value="#request.name"></s:textfield>
<!-- 可以识别 -->
<s:textfield name="name" value="%{#request.name}"></s:textfield>
<p>```</p>

<h2 id="section-1">值栈</h2>

<p>struts2 里面提供本身一种存储机制，类似于域对象</p>

<h3 id="section-2">概念</h3>

<p>以前是把数据放到域对象里面，然后再在jsp中取出。在Struts中既可以把数据放到域对象（Action）也可以放到值栈里面</p>

<p>在action里面把数据放到值栈，再在页面中取出</p>

<h3 id="section-3">获取值栈对象</h3>

<p>位置:action每次访问都是一个新的对象，每个action对象中都存在一个值栈对象。
因此无论在一个action获得多少次值栈对象，都是一样的</p>

<p>获取值栈对象有多种方法</p>

<ol>
  <li>
    <p>通过ActionContext</p>

    <p><code class="highlighter-rouge">java
 ActionContext actionContext = ActionContext.getContext();
 ValueStack valueStack = actionContext.getValueStack();
</code>
### 内部结构</p>
  </li>
</ol>

<p>可以在页面中通过<code class="highlighter-rouge">&lt;s:debug&gt;&lt;/s:debug&gt;</code>来查看当前值栈的内部结构，如下图所示</p>

<p>从图中可以看出在action中没有做任何操作时，栈顶元素是action的引用</p>

<p><img src="01.jpg" alt="p1" /></p>

<p>值栈最重要的分为两部分</p>

<p><img src="02.jpg" alt="p2" /></p>

<ol>
  <li>
    <p>第一部分root，结构是list集合，一般都是操作root里面的数据</p>

    <p><code class="highlighter-rouge">class CompoundRoot extends ArrayList</code></p>
  </li>
  <li>
    <p>第二部分context，结构是map集合</p>

    <p><code class="highlighter-rouge">class OgnlContext extends Object implements Map</code></p>

    <p><img src="03.jpg" alt="p3" /></p>
  </li>
</ol>

<h3 id="section-4">向值栈存放数据</h3>

<p>方法有多种</p>

<ol>
  <li>
    <p>获取值栈对象，用值栈的set方法,结果会向栈顶放入java.util.HashMap对象</p>

    <p><code class="highlighter-rouge">java
 ActionContext actionContext = ActionContext.getContext();
 ValueStack valueStack = actionContext.getValueStack();
 valueStack.set("name", "haha");
</code></p>
  </li>
  <li>
    <p>获取值栈对象，用值栈的push方法,结果会向栈顶放入java.lang.String对象</p>

    <p><code class="highlighter-rouge">valueStack.push("123");</code></p>
  </li>
  <li>
    <p>在action定义变量，生成变量的get方法(主要使用),结果会在本action的引用中找到该值，不会向栈中新加数据</p>

    <p>```java
 private String name;</p>

    <p>public String getName() {
     return name;
 }</p>

    <p>@Override
 public String execute() throws Exception {
     name = “haha”;
     return Action.SUCCESS;
 }
 ```</p>
  </li>
</ol>

<h3 id="section-5">从值栈获取数据</h3>

<ol>
  <li>
    <p>使用struts2的标签+ognl表达式获取值栈数据<code class="highlighter-rouge">&lt;s:property value="ognl表达式"/&gt;</code></p>

    <p>获得字符串<code class="highlighter-rouge">&lt;s:property value="变量名"/&gt;</code></p>

    <p>获得对象<code class="highlighter-rouge">&lt;s:property value="对象名.属性名"/&gt;</code></p>

    <p>获得list集合</p>

    <p>```jsp
 <!-- 方式1 -->
 <code class="highlighter-rouge">&lt;s:property value="list[0]"/&gt;</code>
 <code class="highlighter-rouge">&lt;s:property value="list[0].name"/&gt;</code></p>

    <p><!-- 方式2 常用--></p>
    <s:iterator value="list">
     <s:property value="name" />
 </s:iterator>

    <p><!-- 方式3 和jstl很像，遍历值栈list集合，得到每个user对象，
 加快速度的机制，放到context里面，从context里面获得数据yao加#--></p>
    <s:iterator value="list" var="user">
     <s:property value="#user.name" />
 </s:iterator>
    <p>```</p>

    <ol>
      <li>
        <p>获得set方法放入的值<code class="highlighter-rouge">&lt;s:property value="mapkey"/&gt;</code></p>
      </li>
      <li>
        <p>获得push方法放入的值</p>

        <p>这个比较复杂，因为它没有key，
 如果在action最后做操作<code class="highlighter-rouge">valueStack.push("1");valueStack.push("2");</code>，
 那么栈顶是2，1,可以通过从栈的指定位置读出来</p>

        <p>```jsp</p>
        <s:property value="[0].top" />

        <s:property value="[1].top" />

        <p>```</p>
      </li>
      <li>
        <p>使用jstl+el表达式获取值栈中的数据</p>

        <p>```jsp
 &lt;%@ page language=”java” %&gt;
 &lt;%@ page contentType=”text/html; charset=UTF-8” %&gt;
 &lt;%@ page pageEncoding=”UTF-8”%&gt;
 &lt;%@ taglib uri=”/struts-tags” prefix=”s”%&gt;
 &lt;%@ taglib uri=”http://java.sun.com/jsp/jstl/core” prefix=”c”%&gt;
 &lt;!DOCTYPE html&gt;</p>
        <html>
     <head>
         <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
         <title>Test</title>
     </head>
     <body>
         <s:debug></s:debug>
         <!-- 使用struts2标签+ognl-->
         <s:iterator value="list" var="value">
             <s:property value="#value" />
         </s:iterator>
         <!-- 使用jstl+el表达式--><br />
         <c:foreach items="${list}" var="v">
             ${v}
         </c:foreach>
     </body>
 </html>
        <p>```</p>

        <p>为什么el表达式能够获得数据</p>

        <p>原因是struts2从底层增强request对象里面的方法getAttribute，
 首先从request域获取值，如果获取到直接返回，获取不到则到值栈中把值获取出来，把值放到域对象里</p>

        <p>```java
 public Object getAttribute(String key) {
     if (key == null) {
         throw new NullPointerException(“You must specify a key value”);
     }</p>

        <div class="highlighter-rouge"><pre class="highlight"><code> if (disableRequestAttributeValueStackLookup || key.startsWith("javax.servlet")) {
     // don't bother with the standard javax.servlet attributes, we can short-circuit this
     // see WW-953 and the forums post linked in that issue for more info
     return super.getAttribute(key);
 }

 ActionContext ctx = ActionContext.getContext();
 Object attribute = super.getAttribute(key);

 if (ctx != null &amp;&amp; attribute == null) {
     boolean alreadyIn = isTrue((Boolean) ctx.get(REQUEST_WRAPPER_GET_ATTRIBUTE));

     // note: we don't let # come through or else a request for
     // #attr.foo or #request.foo could cause an endless loop
     if (!alreadyIn &amp;&amp; !key.contains("#")) {
         try {
             // If not found, then try the ValueStack
             ctx.put(REQUEST_WRAPPER_GET_ATTRIBUTE, Boolean.TRUE);
             ValueStack stack = ctx.getValueStack();
             if (stack != null) {
                 attribute = stack.findValue(key);
             }
         } finally {
             ctx.put(REQUEST_WRAPPER_GET_ATTRIBUTE, Boolean.FALSE);
         }
     }
 }
 return attribute;  }  ```
</code></pre>
        </div>
      </li>
    </ol>
  </li>
</ol>
</div>
	</div>
<footer class="footer">
    <span>Copyright © 2016 皖ICP备16016174号</span>
    <a href="/sitemap.xml">网站地图</a>
    <span>Powered by</span>
    <a href="https://github.com/TMaize/tmaize-blog">tmaize-blog</a>
    <div class="up"></div>
</footer>
<script>
    //mta.qq.com 访问统计
    var _mtac = {};
    (function() {
        var mta = document.createElement("script");
        mta.src = "http://pingjs.qq.com/h5/stats.js?v2.0.2";
        mta.setAttribute("name", "MTAH5");
        mta.setAttribute("sid", "500581966");
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(mta, s);
    })();
    //360的自动推送
    (function(){
        var src = (document.location.protocol == "http:") ? "http://js.passport.qihucdn.com/11.0.1.js?0b7f3f19682121293c3e4b62c9740281":"https://jspassport.ssl.qhimg.com/11.0.1.js?0b7f3f19682121293c3e4b62c9740281";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
    })();
    //百度的自动推送
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
</body>
</html>
