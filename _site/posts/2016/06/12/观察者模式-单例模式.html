<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<meta http-equiv="content-language" content="zh-CN" />
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
		<meta name="keywords" content="TMaize,设计模式"/>
		<meta name="author" content="TMaize" />
		<meta name="description" content="观察者模式 单例模式"/>
		<link rel="icon" href="/static/img/favicon.ico" type="image/x-icon" />
		<link rel="shortcut icon" href="/static/img/favicon.ico" type="image/x-icon"/>
		<link rel="stylesheet" href="/static/css/blog.css">
		<link rel="stylesheet" href="/static/css/blog-post.css">
		<script>window.blog={contextPath:""}</script>
		<script type="text/javascript" src="/static/js/blog.js"></script>
		<title>观察者模式 单例模式-TMaize Blog</title>
	</head>
<body>
<header class="header select-none">
    <a class="logo" title="TMaize Blog" href="/">
        <img src="/static/img/logo.jpg">
    </a>
    <a class="title" href="/">TMaize Blog</a>
    <nav class="menu">
        <a href="/">Blog</a>
        <a href="/pages/categories.html">Categories</a>
        <a href="/pages/search.html">Search</a>
        <a href="/pages/links.html">Links</a>
        <a href="/pages/chat.html">Chat</a>
        <a href="/pages/about.html">About</a>
    </nav>
    <span class="icon"></span>
</header>
	<div class="main animation-fadeUp post">
		
		<h1 class="title">观察者模式 单例模式</h1>
		
		<div class="content"><h2 id="section">观察者模式</h2>

<p>有时被称作发布/订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>

<h3 id="section-1">场景</h3>

<p>将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。</p>

<ul>
  <li>
    <p>当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</p>
  </li>
  <li>
    <p>当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。</p>
  </li>
  <li>
    <p>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。</p>
  </li>
</ul>

<h3 id="section-2">模式中的角色</h3>

<ul>
  <li>
    <p>抽象被观察者角色(Subject/Watched)：把所有对观察者对象的引用保存在一个集合中，每个被观察者角色都可以有任意数量的观察者。被观察者提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。</p>
  </li>
  <li>
    <p>抽象观察者角色(Observer/Watcher)：为所有具体的观察者定义一个接口，在得到主题的通知时更新自己。</p>
  </li>
  <li>
    <p>具体被观察者角色(ConcreteSubject)：在被观察者内部状态改变时，给所有登记过的观察者发出通知。具体被观察者角色通常用一个子类实现。</p>
  </li>
  <li>
    <p>具体观察者角色(ConcreteObserver)：该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。通常用一个子类实现。如果需要，具体观察者角色可以保存一个指向具体主题角色的引用。</p>
  </li>
</ul>

<h3 id="section-3">代码实现</h3>

<p>抽象的被观察者</p>

<p>```java
public interface Watched {</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public Watched addWatcher(Watcher watcher);

//public void addWatcher(Watcher watcher);

public void removeWatcher(Watcher watcher);

public void notifyWatchers(); } ```
</code></pre>
</div>

<p>具体的被观察者</p>

<p>```java
public class ConcreteWatched implements Watched {</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private List&lt;Watcher&gt; watchers = new ArrayList&lt;&gt;();

@Override
public Watched addWatcher(Watcher watcher) {
	watchers.add(watcher);
	return this;
}

@Override
public void removeWatcher(Watcher watcher) {
	watchers.remove(watcher);
}

@Override
public void notifyWatchers() {
	
	//采用Watcher代理具体的观察者，只对被观测者提供Watcher接口方法里面的方法
	for (Watcher watcher:watchers) {
		watcher.update();
	}
}
</code></pre>
</div>

<p>}
```</p>

<p>抽象的观察者</p>

<p>```java
public interface Watcher {</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public void update();
</code></pre>
</div>

<p>}
```</p>

<p>具体的的观察者</p>

<p>```java
public class User implements Watcher{</p>

<div class="highlighter-rouge"><pre class="highlight"><code>String name;

private User() {

}

public User(String name) {
	this.name = name;
}

@Override
public void update() {
	System.out.println(name+"收到推送...");
}
</code></pre>
</div>

<p>}
```</p>

<p>测试类</p>

<p>```java
public class Test {
	public static void main(String[] args) {
		ConcreteWatched concreteWatched = new ConcreteWatched();</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	User u1 = new User("KangKang");
	User u2 = new User("XiaoMing");
	concreteWatched.addWatcher(u1).addWatcher(u2);
	
	concreteWatched.notifyWatchers();
	
} } ```
</code></pre>
</div>

<h3 id="section-4">总结</h3>

<p>观察者模式在于目标角色、观察者角色之间的通信，有两个版本。</p>

<p>一种情况便是目标角色在发生变化后，仅仅告诉观察者角色“我变化了”，观察者角色如果想要知道具体的变化细节，则就要自己从目标角色的接口中得到。这种模式被很形象的称为：拉模式——就是说变化的信息是观察者角色主动从目标角色中“拉”出来的。</p>

<p>还有一种方法，那就是我目标角色“服务一条龙”，通知你发生变化的同时，通过一个参数将变化的细节传递到观察者角色中去。这就是“推模式”——管你要不要，先给你啦。</p>

<p>这两种模式的使用，取决于系统设计时的需要。如果目标角色比较复杂，并且观察者角色进行更新时必须得到一些具体变化的信息，则“推模式”比较合适。如果目标角色比较简单，则“拉模式”就很合适。</p>

<h2 id="section-5">单例模式</h2>

<p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务。而且只有一个实例能够减少内存占用，还可以防止实例存在多个会引起的程序逻辑错误。</p>

<p>单例模式是设计模式中最简单的形式之一。这一模式的目的是使得类的一个对象成为系统中的唯一实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。并且这些应用都或多或少具有资源管理器的功能。</p>

<p>单例模式实现的方法较多，但是基本的就两种，懒汉模式和饿汉模式</p>

<h3 id="section-6">懒汉模式</h3>

<p>懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。</p>

<p>```java
public class Singleton {</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private static Singleton singleton = null;

//屏蔽构造方法
private Singleton(){}

//获得单例，存在线程安全问题
public static Singleton getInstance(){
	if(singleton==null){
		singleton = new Singleton();
	}
	return singleton;
}

//.... } ```
</code></pre>
</div>

<p>对于上面的实现会存在线程安全问题，不过可以使用<code class="highlighter-rouge">synchronized</code>关键字来修饰<code class="highlighter-rouge">getInstance()</code>,但是又会带来性能上的影响.可以通过静态内部类来解决这个问题</p>

<p>```java
public class Singleton {</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private static class LazyHolder {
	private static final Singleton INSTANCE = new Singleton();
}

private Singleton() {}

public static final Singleton getInstance() {
	return LazyHolder.INSTANCE;
} } ```
</code></pre>
</div>

<h3 id="section-7">饿汉模式</h3>

<p>饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，所以饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题。但是不管之后会不会使用这个单例，都会占据一定的内存，相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成。</p>

<p>```java
public class Singleton {</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private final static Singleton singleton = new Singleton();

//屏蔽构造方法
private Singleton(){}

//获得单例
public static Singleton getInstance(){
	return singleton;
}

//.... } ```
</code></pre>
</div>
</div>
	</div>
<footer class="footer">
    <span>Copyright © 2016 皖ICP备16016174号</span>
    <a href="/sitemap.xml">网站地图</a>
    <span>Powered by</span>
    <a href="https://github.com/TMaize/tmaize-blog">tmaize-blog</a>
    <div class="up"></div>
</footer>
<script>
    //mta.qq.com 访问统计
    var _mtac = {};
    (function() {
        var mta = document.createElement("script");
        mta.src = "http://pingjs.qq.com/h5/stats.js?v2.0.2";
        mta.setAttribute("name", "MTAH5");
        mta.setAttribute("sid", "500581966");
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(mta, s);
    })();
    //360的自动推送
    (function(){
        var src = (document.location.protocol == "http:") ? "http://js.passport.qihucdn.com/11.0.1.js?0b7f3f19682121293c3e4b62c9740281":"https://jspassport.ssl.qhimg.com/11.0.1.js?0b7f3f19682121293c3e4b62c9740281";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
    })();
    //百度的自动推送
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
</body>
</html>
